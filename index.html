<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NHL Standings + Upcoming Odds (v1.0)</title>
  <style>
    :root { --bg:#0b0f14; --card:#121925; --text:#e8eef7; --muted:#9fb0c6; --line:#243246; --good:#32d583; --bad:#ff4d4d; --accent:#5aa9ff; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    header { padding:14px 14px 10px; position:sticky; top:0; background:linear-gradient(to bottom, rgba(11,15,20,.98), rgba(11,15,20,.80)); backdrop-filter: blur(10px); border-bottom:1px solid var(--line); z-index:10; }
    h1 { margin:0; font-size:18px; letter-spacing:.2px; }
    .sub { margin-top:6px; color:var(--muted); font-size:12px; }
    .wrap { padding:14px; display:grid; gap:12px; grid-template-columns: 1fr; max-width: 1100px; margin: 0 auto; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .card { background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px; }
    label { font-size:12px; color:var(--muted); display:block; margin-bottom:4px; }
    input, select, button { background:#0e1521; color:var(--text); border:1px solid var(--line); border-radius:10px; padding:10px; font-size:14px; }
    input::placeholder { color:#6f86a5; }
    button { cursor:pointer; }
    button.primary { background: #123057; border-color:#1f4d8a; }
    button.primary:hover { filter: brightness(1.06); }
    button.ghost { background:transparent; }
    .pill { font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid var(--line); color:var(--muted); }
    .ok { color: var(--good); border-color: rgba(50,213,131,.35); }
    .warn { color: #ffd166; border-color: rgba(255,209,102,.35); }
    .err { color: var(--bad); border-color: rgba(255,77,77,.35); }
    table { width:100%; border-collapse: collapse; overflow:hidden; border-radius:12px; }
    th, td { padding:10px 8px; border-bottom:1px solid var(--line); font-size:13px; }
    th { text-align:left; font-size:12px; color:var(--muted); position:sticky; top:0; background:#0f1622; }
    tr:hover td { background: rgba(90,169,255,.06); }
    .right { text-align:right; }
    .small { font-size:12px; color:var(--muted); }
    .grid2 { display:grid; gap:12px; grid-template-columns: 1fr; }
    @media (min-width: 920px) { .grid2 { grid-template-columns: 1.3fr .7fr; } }
    .spin { display:inline-block; width:14px; height:14px; border:2px solid rgba(255,255,255,.22); border-top-color: rgba(255,255,255,.85); border-radius:50%; animation: r 1s linear infinite; vertical-align:-2px; margin-right:8px; }
    @keyframes r { to { transform: rotate(360deg); } }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <header>
    <h1>NHL Standings + Upcoming Games + Odds</h1>
    <div class="sub">Standings: NHL API • Schedule: NHL API • Odds: NHL partner odds (if available) or The Odds API (optional key)</div>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="row">
        <div style="min-width:220px; flex: 1;">
          <label>Filter by team (name contains)</label>
          <input id="teamFilter" placeholder="e.g., Leafs, Oilers, Rangers" />
        </div>

        <div style="min-width:170px;">
          <label>Standings view</label>
          <select id="standingsView">
            <option value="league">League (by points)</option>
            <option value="conference">Conference</option>
            <option value="division">Division</option>
          </select>
        </div>

        <div style="min-width:170px;">
          <label>Odds source</label>
          <select id="oddsSource">
            <option value="nhl">NHL partner odds (no key)</option>
            <option value="oddsapi">The Odds API (needs key)</option>
            <option value="off">Off</option>
          </select>
        </div>

        <div style="min-width:170px;">
          <label>Country (NHL partner odds)</label>
          <select id="country">
            <option value="CA">CA</option>
            <option value="US">US</option>
          </select>
        </div>

        <div style="min-width:260px; flex: 1;">
          <label>The Odds API key (optional)</label>
          <input id="oddsApiKey" placeholder="Paste key here (stored in your browser)" />
          <div class="small">Sport key is <span class="mono">icehockey_nhl</span>. :contentReference[oaicite:4]{index=4}</div>
        </div>

        <div class="row" style="margin-left:auto;">
          <button class="primary" id="refreshBtn"><span id="refreshIcon"></span>Refresh</button>
          <span id="status" class="pill">Ready</span>
        </div>
      </div>
    </div>

    <div class="grid2">
      <div class="card">
        <div class="row" style="justify-content:space-between; align-items:baseline;">
          <div>
            <div style="font-weight:700;">Standings</div>
            <div class="small" id="standingsMeta">—</div>
          </div>
          <div class="pill" id="standingsCount">0 teams</div>
        </div>
        <div style="margin-top:10px; overflow:auto; max-height:520px;">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Team</th>
                <th>GP</th>
                <th>W</th>
                <th>L</th>
                <th>OT</th>
                <th class="right">PTS</th>
                <th class="right">P%</th>
                <th class="right">GF</th>
                <th class="right">GA</th>
              </tr>
            </thead>
            <tbody id="standingsBody"></tbody>
          </table>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between; align-items:baseline;">
          <div>
            <div style="font-weight:700;">Upcoming games</div>
            <div class="small" id="gamesMeta">Next games from schedule/now</div>
          </div>
          <div class="pill" id="gamesCount">0 games</div>
        </div>

        <div style="margin-top:10px; overflow:auto; max-height:520px;">
          <table>
            <thead>
              <tr>
                <th>When</th>
                <th>Matchup</th>
                <th class="right">Odds</th>
              </tr>
            </thead>
            <tbody id="gamesBody"></tbody>
          </table>
        </div>

        <div class="small" style="margin-top:10px; line-height:1.35;">
          Notes:
          <ul style="margin:6px 0 0 18px; padding:0;">
            <li>NHL partner odds endpoint: <span class="mono">/v1/partner-game/{country}/now</span>. :contentReference[oaicite:5]{index=5}</li>
            <li>The Odds API can return moneyline (h2h) odds, spreads, totals, etc. :contentReference[oaicite:6]{index=6}</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="small" style="text-align:center; color:var(--muted); padding-bottom:10px;">
      v1.0 • Uses public NHL endpoints for standings/schedule. :contentReference[oaicite:7]{index=7}
    </div>
  </div>

<script>
(() => {
  const el = (id) => document.getElementById(id);

  const NHL_BASE = "https://api-web.nhle.com";
  const ENDPOINTS = {
    standingsNow: () => `${NHL_BASE}/v1/standings/now`,
    scheduleNow: () => `${NHL_BASE}/v1/schedule/now`,
    partnerOddsNow: (country) => `${NHL_BASE}/v1/partner-game/${encodeURIComponent(country)}/now`,
  };

  // The Odds API docs: sport key icehockey_nhl. Regions/markets configurable.
  const ODDSAPI_BASE = "https://api.the-odds-api.com/v4/sports/icehockey_nhl/odds";

  const state = {
    standings: [],
    games: [],
    oddsMap: new Map(), // key -> odds string
    lastUpdated: null,
  };

  function setStatus(text, kind="") {
    const s = el("status");
    s.textContent = text;
    s.className = "pill " + (kind || "");
  }

  function setLoading(isLoading) {
    el("refreshIcon").innerHTML = isLoading ? `<span class="spin"></span>` : "";
    el("refreshBtn").disabled = isLoading;
  }

  function safeNum(n) { return (n === null || n === undefined || Number.isNaN(Number(n))) ? 0 : Number(n); }

  function pct(points, gp) {
    const maxPts = safeNum(gp) * 2;
    if (!maxPts) return 0;
    return (safeNum(points) / maxPts) * 100;
  }

  function normalizeTeamName(name) {
    return (name || "").toLowerCase().replace(/\s+/g, " ").trim();
  }

  function makeGameKey(away, home, isoStart) {
    // Key tries to match across odds sources: teams + date (day)
    const day = (isoStart || "").slice(0,10);
    return `${normalizeTeamName(away)}@${normalizeTeamName(home)}|${day}`;
  }

  async function fetchJson(url, opts={}) {
    const res = await fetch(url, { cache: "no-store", ...opts });
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    return await res.json();
  }

  async function loadStandings() {
    const data = await fetchJson(ENDPOINTS.standingsNow());
    // NHL standings/now returns an object with "standings" array.
    const rows = Array.isArray(data.standings) ? data.standings : [];
    state.standings = rows.map(r => ({
      teamName: r.teamName?.default || r.teamName || "—",
      teamAbbrev: r.teamAbbrev?.default || r.teamAbbrev || "",
      conference: r.conferenceName || "",
      division: r.divisionName || "",
      gp: safeNum(r.gamesPlayed),
      w: safeNum(r.wins),
      l: safeNum(r.losses),
      ot: safeNum(r.otLosses),
      pts: safeNum(r.points),
      gf: safeNum(r.goalFor),
      ga: safeNum(r.goalAgainst),
      rank: safeNum(r.leagueSequence) || 0,
      divRank: safeNum(r.divisionSequence) || 0,
      confRank: safeNum(r.conferenceSequence) || 0,
    }));
    state.lastUpdated = new Date();
  }

  async function loadSchedule() {
    const data = await fetchJson(ENDPOINTS.scheduleNow());
    // schedule/now returns gameWeek array with date blocks and games.
    const weeks = Array.isArray(data.gameWeek) ? data.gameWeek : [];
    const now = Date.now();

    const games = [];
    for (const w of weeks) {
      const days = Array.isArray(w.games) ? w.games : []; // (some responses use different nesting)
      // In practice, schedule/now often has w.games as array of game objects.
      // Also sometimes it has w.dates with games; handle both.
      if (days.length && days[0]?.id) {
        for (const g of days) games.push(g);
      } else if (Array.isArray(w.dates)) {
        for (const d of w.dates) {
          for (const g of (d.games || [])) games.push(g);
        }
      }
    }

    const upcoming = games
      .map(g => {
        const startUTC = g.startTimeUTC || g.startTime || g.gameDate;
        const ms = startUTC ? Date.parse(startUTC) : NaN;
        return {
          id: g.id || g.gameId,
          startTimeUTC: startUTC,
          startMs: ms,
          away: g.awayTeam?.placeName?.default ? `${g.awayTeam.placeName.default} ${g.awayTeam.teamName?.default || ""}`.trim()
                : (g.awayTeam?.name?.default || g.awayTeam?.name || g.awayTeam?.abbrev || "Away"),
          home: g.homeTeam?.placeName?.default ? `${g.homeTeam.placeName.default} ${g.homeTeam.teamName?.default || ""}`.trim()
                : (g.homeTeam?.name?.default || g.homeTeam?.name || g.homeTeam?.abbrev || "Home"),
          awayAbbrev: g.awayTeam?.abbrev || g.awayTeam?.teamAbbrev?.default || "",
          homeAbbrev: g.homeTeam?.abbrev || g.homeTeam?.teamAbbrev?.default || "",
        };
      })
      .filter(g => Number.isFinite(g.startMs) && g.startMs >= (now - 5*60*1000)) // include very near future
      .sort((a,b) => a.startMs - b.startMs)
      .slice(0, 40);

    state.games = upcoming;
  }

  function fmtWhen(ms) {
    try {
      const d = new Date(ms);
      return d.toLocaleString(undefined, { weekday:"short", month:"short", day:"numeric", hour:"numeric", minute:"2-digit" });
    } catch { return "—"; }
  }

  function renderStandings() {
    const filter = normalizeTeamName(el("teamFilter").value);
    const view = el("standingsView").value;

    let rows = state.standings.slice();

    if (filter) rows = rows.filter(r => normalizeTeamName(r.teamName).includes(filter));

    if (view === "league") {
      rows.sort((a,b) => b.pts - a.pts || (b.gf-b.ga) - (a.gf-a.ga) || a.teamName.localeCompare(b.teamName));
    } else if (view === "conference") {
      rows.sort((a,b) => (a.conference || "").localeCompare(b.conference || "")
        || b.pts - a.pts || a.teamName.localeCompare(b.teamName));
    } else {
      rows.sort((a,b) => (a.division || "").localeCompare(b.division || "")
        || b.pts - a.pts || a.teamName.localeCompare(b.teamName));
    }

    el("standingsCount").textContent = `${rows.length} teams`;
    el("standingsMeta").textContent = state.lastUpdated
      ? `Updated ${state.lastUpdated.toLocaleString()}`
      : "—";

    const tb = el("standingsBody");
    tb.innerHTML = "";

    rows.forEach((r, idx) => {
      const p = pct(r.pts, r.gp).toFixed(1);
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="mono">${idx+1}</td>
        <td><strong>${escapeHtml(r.teamName)}</strong> <span class="small mono">${escapeHtml(r.teamAbbrev || "")}</span>
          <div class="small">${escapeHtml(r.conference)} • ${escapeHtml(r.division)}</div>
        </td>
        <td class="mono">${r.gp}</td>
        <td class="mono">${r.w}</td>
        <td class="mono">${r.l}</td>
        <td class="mono">${r.ot}</td>
        <td class="mono right"><strong>${r.pts}</strong></td>
        <td class="mono right">${p}</td>
        <td class="mono right">${r.gf}</td>
        <td class="mono right">${r.ga}</td>
      `;
      tb.appendChild(tr);
    });
  }

  function renderGames() {
    const filter = normalizeTeamName(el("teamFilter").value);
    const tb = el("gamesBody");
    tb.innerHTML = "";

    let games = state.games.slice();
    if (filter) {
      games = games.filter(g =>
        normalizeTeamName(g.away).includes(filter) || normalizeTeamName(g.home).includes(filter) ||
        normalizeTeamName(g.awayAbbrev).includes(filter) || normalizeTeamName(g.homeAbbrev).includes(filter)
      );
    }

    el("gamesCount").textContent = `${games.length} games`;

    games.forEach(g => {
      const key = makeGameKey(g.away, g.home, new Date(g.startMs).toISOString());
      const oddsTxt = state.oddsMap.get(key) || "—";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="mono">${escapeHtml(fmtWhen(g.startMs))}</td>
        <td><strong>${escapeHtml(g.away)}</strong> @ <strong>${escapeHtml(g.home)}</strong></td>
        <td class="right mono">${escapeHtml(oddsTxt)}</td>
      `;
      tb.appendChild(tr);
    });
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  async function loadNhlPartnerOdds() {
    state.oddsMap.clear();
    const country = el("country").value || "CA";
    const data = await fetchJson(ENDPOINTS.partnerOddsNow(country));
    // This endpoint format can vary; we’ll try a few likely shapes.
    const games = []
      .concat(data?.games || [])
      .concat(data?.events || [])
      .concat(data?.gameOdds || []);

    for (const g of games) {
      const start = g.startTimeUTC || g.startTime || g.gameDate || g.commence_time;
      const away = g.awayTeam?.name?.default || g.awayTeam?.name || g.awayTeam || g.away_team || g.away;
      const home = g.homeTeam?.name?.default || g.homeTeam?.name || g.homeTeam || g.home_team || g.home;

      // Try to grab moneyline-like odds
      const mlAway = g?.odds?.moneyline?.away ?? g?.moneylineAway ?? g?.awayOdds ?? g?.awayPrice;
      const mlHome = g?.odds?.moneyline?.home ?? g?.moneylineHome ?? g?.homeOdds ?? g?.homePrice;

      if (!away || !home || !start) continue;
      const key = makeGameKey(away, home, new Date(start).toISOString());

      let txt = "—";
      if (mlAway != null || mlHome != null) txt = `${shortOdds(mlAway)} / ${shortOdds(mlHome)}`; // away/home
      state.oddsMap.set(key, txt);
    }
  }

  function shortOdds(v) {
    if (v === null || v === undefined || v === "") return "—";
    // Keep as-is; some sources already return American (+120) or decimal (1.85)
    return String(v);
  }

  async function loadOddsApi() {
    state.oddsMap.clear();
    const key = (el("oddsApiKey").value || "").trim();
    if (!key) throw new Error("Missing The Odds API key.");

    // Common params:
    // regions: us, us2, uk, eu, au
    // markets: h2h (moneyline)
    // oddsFormat: american or decimal
    const url = new URL(ODDSAPI_BASE);
    url.searchParams.set("apiKey", key);
    url.searchParams.set("regions", "us,us2");
    url.searchParams.set("markets", "h2h");
    url.searchParams.set("oddsFormat", "american");

    const events = await fetchJson(url.toString());
    for (const e of (Array.isArray(events) ? events : [])) {
      const start = e.commence_time;
      const home = e.home_team;
      const away = e.away_team;
      if (!start || !home || !away) continue;

      // Pick first bookmaker that has h2h market
      let awayPrice = null, homePrice = null;
      const b = (e.bookmakers || [])[0];
      const m = (b?.markets || []).find(x => x.key === "h2h");
      if (m?.outcomes?.length) {
        for (const o of m.outcomes) {
          if (normalizeTeamName(o.name) === normalizeTeamName(home)) homePrice = o.price;
          if (normalizeTeamName(o.name) === normalizeTeamName(away)) awayPrice = o.price;
        }
      }

      const key2 = makeGameKey(away, home, new Date(start).toISOString());
      const txt = (awayPrice != null || homePrice != null)
        ? `${shortOdds(awayPrice)} / ${shortOdds(homePrice)}`
        : "—";
      state.oddsMap.set(key2, txt);
    }
  }

  function saveSettings() {
    localStorage.setItem("nhlapp.teamFilter", el("teamFilter").value || "");
    localStorage.setItem("nhlapp.view", el("standingsView").value || "league");
    localStorage.setItem("nhlapp.oddsSource", el("oddsSource").value || "nhl");
    localStorage.setItem("nhlapp.country", el("country").value || "CA");
    // store key only if user typed it
    localStorage.setItem("nhlapp.oddsApiKey", el("oddsApiKey").value || "");
  }

  function loadSettings() {
    el("teamFilter").value = localStorage.getItem("nhlapp.teamFilter") || "";
    el("standingsView").value = localStorage.getItem("nhlapp.view") || "league";
    el("oddsSource").value = localStorage.getItem("nhlapp.oddsSource") || "nhl";
    el("country").value = localStorage.getItem("nhlapp.country") || "CA";
    el("oddsApiKey").value = localStorage.getItem("nhlapp.oddsApiKey") || "";
  }

  async function refreshAll() {
    setLoading(true);
    setStatus("Refreshing…", "warn");
    try {
      saveSettings();

      await Promise.all([loadStandings(), loadSchedule()]);

      const src = el("oddsSource").value;
      if (src === "nhl") {
        try {
          await loadNhlPartnerOdds();
          setStatus("Loaded standings + games + NHL odds", "ok");
        } catch (e) {
          // Odds are optional; still show app
          state.oddsMap.clear();
          setStatus("Loaded standings + games (NHL odds unavailable)", "warn");
        }
      } else if (src === "oddsapi") {
        await loadOddsApi();
        setStatus("Loaded standings + games + Odds API odds", "ok");
      } else {
        state.oddsMap.clear();
        setStatus("Loaded standings + games (odds off)", "ok");
      }

      el("gamesMeta").textContent = "Next games from schedule/now • Odds shown as Away/Home";
      renderStandings();
      renderGames();
    } catch (err) {
      console.error(err);
      setStatus(`Error: ${err.message || err}`, "err");
      renderStandings();
      renderGames();
    } finally {
      setLoading(false);
    }
  }

  // UI events
  ["teamFilter","standingsView","oddsSource","country","oddsApiKey"].forEach(id => {
    el(id).addEventListener("input", () => {
      saveSettings();
      renderStandings();
      renderGames();
    });
    el(id).addEventListener("change", () => {
      saveSettings();
      renderStandings();
      renderGames();
    });
  });

  el("refreshBtn").addEventListener("click", refreshAll);

  // Init
  loadSettings();
  refreshAll();
})();
</script>
</body>
</html>
